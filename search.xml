<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VUE学习记录</title>
    <url>/2023/09/24/VUE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="VUE-LEARN"><a href="#VUE-LEARN" class="headerlink" title="VUE LEARN"></a>VUE LEARN</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>用于单向绑定事件，数据变化时重新渲染，界面变化不引起数据变化</p>
<p>:[v]&#x3D;“line”</p>
<p>v-bind得到的是表达式而不是一个字符串，可以利用这一点向一个组件菜单非字符串参数</p>
<span id="more"></span>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>用于双向绑定事件，数据变化时重新渲染，界面变化也引起数据变化</p>
<p>v-model&#x3D;“line”</p>
<p>.lazy是懒惰更新，在组件失去焦点时更新数据</p>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>用于绑定事件的监听函数</p>
<p>@[even]&#x3D;value</p>
<p>修饰符：.once (只触发一次)，……</p>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>用于便捷的设置dom是否显示，原理是设置display属性</p>
<p>v-show&#x3D;“boolean”</p>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>条件判断命令，若干条逻辑相连的语句必须相邻</p>
<p>v-if&#x3D;“boolean”</p>
<p>v-else-if&#x3D;“boolean”</p>
<p>v-else</p>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>循环语句</p>
<p>借助js原生数组方法进行排序和过滤</p>
<ul>
<li><p>遍历数组</p>
<p>v-for&#x3D;“(data,index) of value”</p>
</li>
<li><p>遍历字符串</p>
<p>v-for&#x3D;“(data,index) of str”</p>
</li>
<li><p>遍历指定次数</p>
<p>v-for&#x3D;“(data,index) of 5(num)”</p>
</li>
</ul>
<h4 id="key-key-…"><a href="#key-key-…" class="headerlink" title="key(:key&#x3D;…)"></a>key(:key&#x3D;…)</h4><p>用于循环语句中</p>
<p>用来标识每一个遍历对象。</p>
<p>当遍历对象变化时，通过对比算法对比虚拟dom来覆盖原有的虚拟dom</p>
<h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><p>设置组件中的文本</p>
<p>例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//设置组件中的文本</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><p>设置组件中的文本,可以将文本解析为dom节点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//设置组件中的文本,可以将文本解析为dom节点</span><br><span class="line">value=&quot;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>kk<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>当vue开始执行时会删除该标签，配合css用于js加载前页面元素的隐藏</p>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>类似于v-bind,但是只在页面初始化时执行一次，之后数据变化也不再执行</p>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>跳过vue的解析，不解析其中的vue语法，加快页面的解析</p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>显示变量的返回值</p>
<h2 id="vue相关原理"><a href="#vue相关原理" class="headerlink" title="vue相关原理"></a>vue相关原理</h2><h3 id="vue开发者工具"><a href="#vue开发者工具" class="headerlink" title="vue开发者工具"></a>vue开发者工具</h3><h3 id="vue检测对象变化的原理"><a href="#vue检测对象变化的原理" class="headerlink" title="vue检测对象变化的原理"></a>vue检测对象变化的原理</h3><h4 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h4><p>以原对象为模板构造新对象，使用gette和setter达到目的</p>
<p>setter无法检测一个数组和对象的属性的改变（在新对象和原对象上都不可以完成对整体的更改，也不可以检测到改变）</p>
<p>在vue2(vue2使用setter,getter)中直接在原对象上增加属性不会在新对象中增加setter，不会检测到变化,可以使用Vue.set函数动态增加响应式的数据</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a=&#123;<span class="attr">x</span>:[<span class="number">1</span>]&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a,<span class="string">&quot;y&quot;</span>,&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="property">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">v</span>)&#123;</span><br><span class="line">        a.<span class="property">x</span>=v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//会触发setter</span></span><br><span class="line">a.<span class="property">y</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">//向其中增加数组元素不会触发setter</span></span><br><span class="line">a.<span class="property">y</span>.<span class="title function_">push</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//增加属性不会触发setter</span></span><br><span class="line">a.<span class="property">y</span>.<span class="property">a</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h4><p>以原对象为模板构造新对象，使用代理达到目的</p>
<p>可以检测到对象和数组属性的变化（在新对象和原对象上都可以完成更改，但仅仅在新对象上可以检测到改变）。</p>
<p>在vue3(vue3使用代理)中直接在原对象上增加属性，该操作vue3不会检测到变化,vue3中Vue.set函数(由于vue3使用了代理))被废弃，使用了新的函数。</p>
<p>直接在原对象上增加属性会在新对象中增加属性,如果该属性是data数组中的一个对象上的某个属性，会在新对象中增加该属性。如果该属性是data数组中的一个不存在的对象，且如果在html中未使用该不存在的对象，也会在新对象中增加该属性，而如果在html中使用该不存在的对象，会给出警告，且不会在新对象中增加该属性。</p>
<h3 id="对象代理"><a href="#对象代理" class="headerlink" title="对象代理"></a>对象代理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object.<span class="title function_">defineproperty</span>(object,name,&#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><h3 id="vue的不同使用方式"><a href="#vue的不同使用方式" class="headerlink" title="vue的不同使用方式"></a>vue的不同使用方式</h3><h4 id="通过script标签引入"><a href="#通过script标签引入" class="headerlink" title="通过script标签引入"></a>通过script标签引入</h4><p>使用简单，但是部分vue简化语法不可以如：</p>
<ul>
<li><p>自定义组件标签无法自闭合</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//正确</span><br><span class="line"><span class="tag">&lt;<span class="name">custom</span>&gt;</span><span class="tag">&lt;/<span class="name">custom</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">custom</span>&gt;</span><span class="tag">&lt;/<span class="name">custom</span>&gt;</span></span><br><span class="line">//这种方法下错误</span><br><span class="line"><span class="tag">&lt;<span class="name">custom</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">custom</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组件的命名问题</p>
<ol>
<li>使用大小写会导致错误</li>
<li>推荐使用“-”</li>
</ol>
</li>
</ul>
<h4 id="通过脚手架使用"><a href="#通过脚手架使用" class="headerlink" title="通过脚手架使用"></a>通过脚手架使用</h4><p>可以完整使用vue的功能</p>
<h2 id="vue配置属性"><a href="#vue配置属性" class="headerlink" title="vue配置属性"></a>vue配置属性</h2><h3 id="data-数据属性"><a href="#data-数据属性" class="headerlink" title="data(数据属性)"></a>data(数据属性)</h3><p>相关属性</p>
<h3 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed(计算属性)"></a>computed(计算属性)</h3><p>类似于data,但是在相关数据变化时才调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="attr">test</span>:&#123;</span><br><span class="line">        <span class="comment">//特殊语法,由vue解析</span></span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="watch-监视属性"><a href="#watch-监视属性" class="headerlink" title="watch(监视属性)"></a>watch(监视属性)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="comment">//直接使用要监视的变量名</span></span><br><span class="line">    <span class="attr">value</span>:&#123;</span><br><span class="line">        <span class="comment">//是否深度监视value(如嵌套结构),默认false</span></span><br><span class="line">        <span class="attr">deep</span>:boolean</span><br><span class="line">        <span class="comment">//初始化时是否调用，默认false</span></span><br><span class="line">        <span class="attr">immediate</span>:boolean</span><br><span class="line">        <span class="comment">//value值变化时调用</span></span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">changed,past</span>)&#123;<span class="comment">//可以看到修改后的值和修改前的值</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用要监视的变量名的字符串(可以监视嵌套结构中某一个属性的变化)</span></span><br><span class="line">    <span class="string">&quot;value.a.b&quot;</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="methods（方法属性）"><a href="#methods（方法属性）" class="headerlink" title="methods（方法属性）"></a>methods（方法属性）</h3><p>数据（无论是否相关）变化时就调用</p>
<h3 id="filters-过滤器"><a href="#filters-过滤器" class="headerlink" title="filters(过滤器)"></a>filters(过滤器)</h3><p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">fun()&#123;&#125;</span><br><span class="line">fun2()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;value | fun | fun2 | ...&#125;&#125; //将value传入fun并将fun的返回值传入fun2继续调用下去直到结束后将返回值返回</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>全局过滤器</p>
<p>Vue.fliter(“name”,()&#x3D;&gt;{})</p>
<h3 id="directives-自定义指令设置"><a href="#directives-自定义指令设置" class="headerlink" title="directives(自定义指令设置)"></a>directives(自定义指令设置)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue2中设置</span></span><br><span class="line"><span class="comment">//函数的this为windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局vue指令写法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;name&quot;</span>,&#123;...&#125;)</span><br><span class="line">                      </span><br><span class="line"><span class="comment">//单个组件vue指令写法                      </span></span><br><span class="line"><span class="attr">directives</span>:&#123;</span><br><span class="line">    <span class="comment">//自定义指令为v-value</span></span><br><span class="line">    <span class="comment">//指令调用时机:1.组件初始化时.2.组件中数据变化导致组件更新时(类似于methods中的函数)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用有两种方式，一种简化版，一种完整版</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//简化版</span></span><br><span class="line">    <span class="title function_">value</span>(<span class="params">element,binding</span>)&#123;<span class="comment">// element代表该指令绑定的dom元素,binding代表与该该指令相关的值，如binding.value代表v-value后赋的值</span></span><br><span class="line">        <span class="comment">//在这里操纵dom,完成操作</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//完整版</span></span><br><span class="line">    <span class="attr">value</span>:&#123;</span><br><span class="line">        <span class="comment">//指令与元素绑定时</span></span><br><span class="line">        <span class="title function_">bind</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        <span class="comment">//元素插入页面时</span></span><br><span class="line">        <span class="title function_">inserted</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        <span class="comment">//组件更新时</span></span><br><span class="line">        <span class="title function_">update</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="template-模板"><a href="#template-模板" class="headerlink" title="template(模板)"></a>template(模板)</h3><p>当组件中未有任何元素是使用模板可以为其中添加元素。该模板会覆盖原有内容。</p>
<h3 id="components-组件"><a href="#components-组件" class="headerlink" title="components(组件)"></a>components(组件)</h3><p>向当前组件中添加子组件。</p>
<h3 id="name-组件名称"><a href="#name-组件名称" class="headerlink" title="name(组件名称)"></a>name(组件名称)</h3><p>指定组件在开发者工具中的名称</p>
<h3 id="render-渲染器"><a href="#render-渲染器" class="headerlink" title="render(渲染器)"></a>render(渲染器)</h3><p>在vue的脚手架项目中，默认引入的是一个简化版的vue，这个简化版的vue不支持template，因为为了提供页面的渲染速度。可以通过修改导入方式引入完整版的vue或修改node_moudle&#x2F;vue中的导入配置文件。</p>
<p>代替template的功能，向页面添加元素。</p>
<h3 id="props-参数"><a href="#props-参数" class="headerlink" title="props(参数)"></a>props(参数)</h3><p>用于外部向组件内传递若干的数据参数，传入后变量使用类似于data。</p>
<p>尽量不要修改外部传入的props参数，会有警告。</p>
<p>不能使用若干vue使用的关键字作为参数名，如：ref,key等等</p>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//通过以下方式构造</span><br><span class="line">//1.简单接收</span><br><span class="line">props:[&quot;re1&quot;,&quot;re2&quot;,&quot;re3&quot;]  // 相当于若干的变量</span><br><span class="line">//2.类型检查，当外部传入参数时会进行检查，当与期望类型不符合时会进行警告</span><br><span class="line">props:&#123;</span><br><span class="line">re1:String</span><br><span class="line">re2:Number</span><br><span class="line">&#125;</span><br><span class="line">//3.完整写法</span><br><span class="line">props:&#123;</span><br><span class="line">rel:&#123;</span><br><span class="line">type:String  //类型检测(可不写)</span><br><span class="line">required:true //设置该属性是否必须设置填写</span><br><span class="line">default:value //设置该属性默认值(当用户未填写该属性时使用)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用方式</span><br><span class="line"><span class="tag">&lt;<span class="name">自定义组件名称</span> <span class="attr">rel</span>=<span class="string">&quot;12&quot;</span> <span class="attr">re2</span>=<span class="string">&quot;good&quot;</span> <span class="attr">:re3</span>=<span class="string">&quot;4+7&quot;</span>&gt;</span>  //可在标签中向组件传递参数,并且可以结合v-bind实现传递非字符串值</span><br></pre></td></tr></table></figure>

<h3 id="mixins-混合"><a href="#mixins-混合" class="headerlink" title="mixins(混合)"></a>mixins(混合)</h3><p>不同组件之间的功能有一定重叠时，可以将这部分代码分离为一个新的js文件，之后通过引入实现功能</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//vue文件中</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">import</span> &#123;fun,...&#125; <span class="keyword">from</span> ./....</span><br><span class="line">...</span><br><span class="line"><span class="attr">mixins</span>:[fun,...]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过Vue.mixin(fun_name)可以进行全局混合，全局混合后所有的组件上都会有这个属性</p>
<h2 id="vue生命周期函数"><a href="#vue生命周期函数" class="headerlink" title="vue生命周期函数"></a>vue生命周期函数</h2><h3 id="vue2-1"><a href="#vue2-1" class="headerlink" title="vue2"></a>vue2</h3><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h4><p>组件初始化(生命周期，事件)，但此时data以及methods还未初始化，无法使用</p>
<h4 id="created"><a href="#created" class="headerlink" title="created"></a>created</h4><p>组件初始化(数据监听，代理),可以使用data和methods</p>
<h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h4><p>vue开始解析模板，并生成虚拟dom，但还未改变真实dom,此时对真实dom的操作会在下一个周期被覆盖</p>
<h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><p>在组件被挂载到页面,虚拟dom被转化为真实dom。</p>
<h4 id="beforeUpdata"><a href="#beforeUpdata" class="headerlink" title="beforeUpdata"></a>beforeUpdata</h4><p>在组件中的数据更新后，但数据的更新还未反映到dom(也未更新虚拟dom)前调用</p>
<h4 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h4><p>组件的数据和页面都更新之后调用</p>
<h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h4><p>组件销毁之前，此时组件中的一切都存在未被开始销毁，可以调用组件中存在的对象。可以更改组件的事件数据，但此时对于数据的更改不会反映到真实的dom上</p>
<h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><p>可以通过vm(组件名).destroy()开始销毁。</p>
<p>组件销毁后，在此之前组件中的自定义事件，vue指令，对数据的监听都已被销毁，与其他组件的连接也都已经断开,但是已经添加到页面上的html,js相关的事件不会被删除,如计时器不会被删除</p>
<p>组件销毁会销毁掉和vue相关的对象，如不会再有数据的更新，自定义事件也会消失，<code>&#123;&#123;&#125;&#125;</code>语法中的变量不再随数据变化改变</p>
<h2 id="vue插件（plugin）"><a href="#vue插件（plugin）" class="headerlink" title="vue插件（plugin）"></a>vue插件（plugin）</h2><p>用于增强vue的功能</p>
<p>vue插件相当于一个对象，这个对象内部需要实现一个特定的方法install</p>
<p>这个方法可以得到Vue（相当于vm的构造函数）作为参数，可以修改Vue的功能</p>
<p>使用Vue.use(插件名称,参数1，参数2, …)来使用插件,该函数中的参数1-n再搭配Vue可以作为参数传入插件中的install函数</p>
<p>此方法可以搭配Vue.filter,Vue.mixin,Vue.directive来向全局动态的增删过滤器，混入，自定义指令等等</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><p>单文件组件</p>
<p>要使用脚手架或webpack才能使用，文件后缀为.vue</p>
</li>
<li><p>非单文件组件</p>
<p>可以写原生的js代码</p>
</li>
</ul>
<h3 id="vue2-2"><a href="#vue2-2" class="headerlink" title="vue2"></a>vue2</h3><h4 id="如何构造"><a href="#如何构造" class="headerlink" title="如何构造"></a>如何构造</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用以下方法构造</span></span><br><span class="line">a=<span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="comment">//与new Vue()和Vue.createApp的配置类似</span></span><br><span class="line">    <span class="comment">//但el不可以配置</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果未使用Vue.extend函数，而是单纯的写的如下所示，在注册组件时vue可以自动调用extend方法，不会报错</span></span><br><span class="line">a=&#123;</span><br><span class="line">    <span class="comment">//与new Vue()和Vue.createApp的配置类似</span></span><br><span class="line">    <span class="comment">//但el不可以配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h4><ol>
<li><p>创建设计组件</p>
</li>
<li><p>注册组件（局部注册&amp;&amp;全局注册）</p>
<ol>
<li><p>局部注册</p>
<p>在组件内部的components内直接注册</p>
</li>
<li><p>全局注册</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;name&quot;</span>,组件名)  </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>编写组件标签</p>
</li>
</ol>
<h3 id="组件原理"><a href="#组件原理" class="headerlink" title="组件原理"></a>组件原理</h3><ul>
<li>通过调用Vue.extend返回了一个组件的构造函数，通过该组件的构造函数来实现生成组件</li>
<li>VueComponent和Vue实例对象(通过new Vue()实现)不同，VC相当于组件类，VM相当于一个实例的调用。不过VC和VM中的属性差异不大</li>
<li>vm可以写el，而vc不可以，只能依附在vm上</li>
</ul>
<h3 id="组件自定义事件"><a href="#组件自定义事件" class="headerlink" title="组件自定义事件"></a>组件自定义事件</h3><p>可以通过在组件上设置自定义事件完成组件之间的通信。</p>
<p>例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在组件上添加自定义事件</span></span><br><span class="line"><span class="comment">//通过触发html事件后调用函数，在函数内触发自定义事件</span></span><br><span class="line"><span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&quot;自定义事件名称&quot;</span>,向调用自定义事件的处理函数传递的参数，...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为自定义事件添加处理函数</span></span><br><span class="line"><span class="variable language_">this</span>.$on(<span class="string">&quot;自定义事件名&quot;</span>,<span class="string">&quot;处理函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件监听在自定义事件</span></span><br><span class="line">&lt;组件 @自定义事件名=<span class="string">&quot;处理函数名&quot;</span>&gt;</span><br><span class="line">处理函数（自定义事件传入的参数）&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解绑自定义事件</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">off</span>(<span class="string">&quot;事件名称&quot;</span>)     <span class="comment">//解绑单个事件</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">off</span>([事件名,...])  <span class="comment">//解绑多个事件</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">off</span>()  <span class="comment">//解绑所有自定义事件</span></span><br></pre></td></tr></table></figure>

<p>自定义事件处理函数中的this指向触发该事件的组件。</p>
<p>在组件上添加对于事件的监听处理默认的会当成自定义事件，如果要使用原生事件需要加上后缀.native</p>
<p>例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;组件标签 @click=<span class="string">&quot;fun&quot;</span>&gt;  <span class="comment">//会当成自定义事件</span></span><br><span class="line">&lt;组件标签 @click.<span class="property">native</span>=<span class="string">&quot;fun&quot;</span>&gt;  <span class="comment">//会当成原生事件</span></span><br></pre></td></tr></table></figure>

<h3 id="组件插槽-solt"><a href="#组件插槽-solt" class="headerlink" title="组件插槽(solt)"></a>组件插槽(solt)</h3><p>默认的组件的使用为：&lt;组件名  &#x2F;&gt;</p>
<p>这样使用组件无法在组件内部再添加东西，可以使用组件插槽来可以使用以下写法：&lt;组件名&gt;…(各种组件)…&lt;&#x2F;组件名&gt;</p>
<p>插槽有不同的种类：</p>
<ol>
<li><p>默认插槽 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//被调用的文件</span><br><span class="line"><span class="tag">&lt;<span class="name">组件名</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">添加若干dom</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">组件名</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//组件文件</span><br><span class="line"><span class="tag">&lt;<span class="name">solt</span>&gt;</span>默认内容,当未向插槽填充内容时使用该默认内容<span class="tag">&lt;/<span class="name">solt</span>&gt;</span>   //没有名字的插槽</span><br><span class="line"></span><br><span class="line">//当出现多个无名插槽时，会将添加的若干dom重复放在两个插槽</span><br><span class="line"><span class="tag">&lt;<span class="name">solt</span>&gt;</span><span class="tag">&lt;/<span class="name">solt</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">solt</span>&gt;</span><span class="tag">&lt;/<span class="name">solt</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
</li>
<li><p>具名插槽</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//被调用的文件</span><br><span class="line"><span class="tag">&lt;<span class="name">组件名</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">solt</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">solt</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">//另外一种写法</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-solt:</span>&quot;<span class="attr">footer</span>&quot;&gt;</span> //仅用于template标签</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">组件名</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//组件文件</span><br><span class="line"><span class="tag">&lt;<span class="name">solt</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span>默认内容,当未向插槽填充内容时使用该默认内容<span class="tag">&lt;/<span class="name">solt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">solt</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>默认内容,当未向插槽填充内容时使用该默认内容<span class="tag">&lt;/<span class="name">solt</span>&gt;</span>   //vue会在对应名字的插槽中插入内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域插槽</p>
<p>用于需要在父组件中向子组件传递一些样式，但样式中需要用到的数据在子组件中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//被调用的文件</span><br><span class="line"><span class="tag">&lt;<span class="name">组件名</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">一些内容,内部用的了vue语法，使用的变量和数据来自于子组件&#123;&#123;&#125;&#125;    </span><br><span class="line">如：&#123;&#123;value&#125;&#125;  //父组件未有value变量，而子组件有</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span>   //必须包裹template且使用参数scope(不是scoped),不然会报错，vue会错误的把其中用的数据当成本组件中的，而不是子组件,scope=&quot;name&quot;中的name存储着从插槽传来的所有数据，包裹在了一个对象中</span><br><span class="line"></span><br><span class="line">//组件文件</span><br><span class="line"><span class="tag">&lt;<span class="name">solt</span> <span class="attr">:value</span>=<span class="string">value</span>  //<span class="attr">向插槽中传递数据</span>，<span class="attr">父组件使用时可以得到这部分数据</span>&gt;</span>默认内容,当未向插槽填充内容时使用该默认内容<span class="tag">&lt;/<span class="name">solt</span>&gt;</span>   //没有名字的插槽</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h3><ol>
<li><p>父子组件之间的通信</p>
<ol>
<li><p>父对子</p>
<ul>
<li>在子组件中设置props,父组件通过在子组件的参数中传递对象实现通信</li>
<li>通过ref标识一个组件，完成对子组件的操纵</li>
</ul>
</li>
<li><p>子对父</p>
<ul>
<li>通过props让父组件传递一个用于通信的函数实现与父组件的通信</li>
</ul>
</li>
<li><p>自定义事件通信</p>
<p>可以通过在组件上设置自定义事件完成组件之间的通信。</p>
<p>例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在组件上添加自定义事件</span></span><br><span class="line"><span class="comment">//通过触发html事件后调用函数，在函数内触发自定义事件</span></span><br><span class="line"><span class="title function_">method</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&quot;自定义事件名称&quot;</span>,向调用自定义事件的处理函数传递的参数，...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为自定义事件添加处理函数</span></span><br><span class="line"><span class="variable language_">this</span>.$on(<span class="string">&quot;自定义事件名&quot;</span>,<span class="string">&quot;处理函数&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件监听在自定义事件</span></span><br><span class="line">&lt;组件 @自定义事件名=<span class="string">&quot;处理函数名&quot;</span>&gt;</span><br><span class="line">处理函数（自定义事件传入的参数）&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>全局事件总线</p>
<p>使用全局事件总线相当于给所有组件的原型上添加一个组件用于组件之间的信息传递</p>
<p>例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>  <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">render</span>:<span class="function"><span class="params">h</span>=&gt;</span><span class="title function_">h</span>(app),</span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.(通信组件名,如$bus)=<span class="variable language_">this</span>  <span class="comment">//安装全局事件总线</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过各个组件向通信组件增删事件，监听，触发事件完成事件之间的通信。但要注意在组件创建时向通信组件添加事件，当组件销毁时要删除通信组件中的事件。</p>
</li>
<li><p>消息的订阅与分布</p>
<p>与事件总线类似，有一个发布者和几个定义者，发布者向订阅者传递信息。需要额外安装新的第三方库，或者自己实现它。</p>
</li>
</ol>
<h2 id="vue相关知识"><a href="#vue相关知识" class="headerlink" title="vue相关知识"></a>vue相关知识</h2><h3 id="组件对于参数的解释"><a href="#组件对于参数的解释" class="headerlink" title="组件对于参数的解释"></a>组件对于参数的解释</h3><p>组件内部所写的属性如果没有使用props设置接收会统一地进入vc对象的一个属性中($attrs)</p>
<p>组件内部所用的插槽如果没有设置也会被vc对象的一个属性接收($slots)</p>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>template不破坏结构,使用v-if</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">执行前：</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">执行后:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="transition-动画效果"><a href="#transition-动画效果" class="headerlink" title="transition(动画效果)"></a>transition(动画效果)</h3><p>vue定义的标签，可以在组件显示或隐藏时播放自定义动画，动画需要在css中设置特定的名称。</p>
<h3 id="class-style等属性的改变"><a href="#class-style等属性的改变" class="headerlink" title="class&amp;style等属性的改变"></a>class&amp;style等属性的改变</h3><p>vue可以使用以下语法简化html属性的改变</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">class:[&quot;d0&quot;,&quot;d1&quot;]</span><br><span class="line">style:&#123;</span><br><span class="line">font-size:10px,</span><br><span class="line">display:flex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-blind:class</span>=<span class="string">&quot;class&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="scoped的使用"><a href="#scoped的使用" class="headerlink" title="scoped的使用"></a>scoped的使用</h3><p>在不同的组件中设置了不同的组件样式，这些样式之间可能会发生冲突，导致部分样式被覆盖，scoped可以避免这个问题。</p>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>...<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span>...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span>...<span class="tag">&lt;/<span class="name">style</span>&gt;</span>  //可以在此添加scoped来限制样式的作用域于本组件，不会影响其他组件。</span><br></pre></td></tr></table></figure>

<p>原理是通过向组件添加一个特定的独一无二的属性值来标识限制样式的使用</p>
<h3 id="vue特有属性的使用"><a href="#vue特有属性的使用" class="headerlink" title="vue特有属性的使用"></a>vue特有属性的使用</h3><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>ref是一个vue设置的标签属性，可以用于标识一个元素（和id类似),通过ref&#x3D;value，标识后的元素会存储在该组件的vc中的$refs属性中的value中。当用ref标识一个组件时，不会标识一个真实的dom元素，而是一个vc对象。</p>
<p>可以通过ref进行组件之间的通信</p>
<h3 id="html表单"><a href="#html表单" class="headerlink" title="html表单"></a>html表单</h3><p>使用v-model完成双向绑定，默认绑定value值。但有的组件不使用value值，vue有特定的解决方法</p>
<ol>
<li><p>text</p>
<p>使用value值</p>
</li>
<li><p>radio</p>
<p>radio类型未有value值，可以自行配置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//使用name属性可以使其变成一组，一组中只能选择一个，不能多选</span><br><span class="line">男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">女<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">//将value绑定到以上两个组件，选择哪个，value的值为对于组件的value值。相当于value值相同的组件显示，其他隐藏</span><br></pre></td></tr></table></figure>
</li>
<li><p>checkbox</p>
<p>checkbox类型未有value值，可以自行配置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//当未在组件添加value属性时，value使用组件的是否勾选的boolean值，并会影响到所有组件的勾选状态</span><br><span class="line">//当在组件添加value属性时，value使用组件的value，变成一个列表，会在列表中添加已勾选组件的value值</span><br><span class="line">男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">女<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">//将value绑定到多个组件，value列表的初始值即为组件勾选的初始情况</span><br></pre></td></tr></table></figure>
</li>
<li><p>select</p>
<p>情况和radio类似，value使用当前选中的option组件的value值</p>
</li>
</ol>
<h3 id="网页发送请求的方式"><a href="#网页发送请求的方式" class="headerlink" title="网页发送请求的方式"></a>网页发送请求的方式</h3><ol>
<li><p>xhr</p>
<p>最原始的方法</p>
</li>
<li><p>jQuery的ajax</p>
<p>是对xhr的封装</p>
</li>
<li><p>axios</p>
<p>对xhr的另一种封装</p>
</li>
<li><p>fetch</p>
<p>另一种原生的请求方式</p>
</li>
<li><p>vue-resource</p>
<p>vue插件，对xhr的封装,vue团队已不再维护</p>
</li>
</ol>
<h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><p>由于浏览器同源策略的限制，无法跨域请求。但是请求可以送达，只是浏览器拦截了反馈。</p>
<p>解决方法：</p>
<ol>
<li><p>cors</p>
<p>让要请求的服务器返回的内容加上一些特殊的标识用于让浏览器识别通过。</p>
</li>
<li><p>jsonp</p>
<p>利用了web通过<script>标签的scr引入数据不会被同源策略限制，但需要前后端之间的配合。</p>
</li>
<li><p>配置代理服务器</p>
<p>让前端界面先向自己的服务器发生请求，让自己（代理）的服务器向目标服务器发送请求，最后再借助代理服务器返回信息。（利用服务器之间通信没有同源限制）</p>
<p>可以通过vue脚手架配置代理服务器。</p>
</li>
</ol>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>一个vue中重要的插件，用于管理多个有状态依赖的组件的状态。</p>
<p>思想:将数据统一保管在一个地方，使用时进行调用。需要对vuex进行一定的配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用法示例</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vuex的第一个流程，用于响应一些动作</span></span><br><span class="line"><span class="keyword">const</span> actions=&#123;</span><br><span class="line">    <span class="title function_">fun</span>(<span class="params">context,value,...</span>)&#123;</span><br><span class="line">        <span class="comment">//第一个参数context相当于上下文，一个简化版的vuex对象，有commit,value及后面的参数为用户传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vuex的第二个流程，用于完成对state中数据的操作</span></span><br><span class="line"><span class="keyword">const</span> mutations=&#123;</span><br><span class="line">    <span class="title function_">fun</span>(<span class="params">state,value,...</span>)&#123;</span><br><span class="line">        <span class="comment">//第一个参数state相当于vuex对象中state模块中存储的数据，value及后面的参数为用户传入的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vuex的第三个流程，用于存储数据的状态</span></span><br><span class="line">cont state=&#123;</span><br><span class="line">    <span class="attr">value1</span>:...,</span><br><span class="line">    <span class="attr">value2</span>:...,</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在此处放需要使用的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于使用state中的属性</span></span><br><span class="line"><span class="keyword">const</span> getters=&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="VUEX模块化"><a href="#VUEX模块化" class="headerlink" title="VUEX模块化"></a>VUEX模块化</h3><p>vuex模块化是将vuex的不同业务按照逻辑分别存储在不同的模块里</p>
<h2 id="router-路由"><a href="#router-路由" class="headerlink" title="router(路由)"></a>router(路由)</h2><p>通常使用在单页面应用中，用于刷新页面的部分内容</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单独的配置文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入组件</span></span><br><span class="line">impor <span class="title class_">About</span> <span class="keyword">from</span> ...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="comment">//设置路由规则</span></span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//路径和组件</span></span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span></span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:...</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//引入路由</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(vueRouter)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//路由的使用</span></span><br><span class="line">&lt;router-link <span class="keyword">class</span>=<span class="string">&quot;...&quot;</span> active-<span class="keyword">class</span>=<span class="string">&quot;...&quot;</span> to=<span class="string">&quot;/...&quot;</span> &gt;&lt;...&gt;  <span class="comment">//使用router-link代替a标签，实现url的切换</span></span><br><span class="line">&lt;router-view&gt;&lt;...&gt;   <span class="comment">//指定组件的呈现位置</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>多个路由的嵌套使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="comment">//设置路由规则</span></span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//路径和组件</span></span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span></span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">            <span class="attr">children</span>:[</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;a1&#x27;</span></span><br><span class="line">                <span class="attr">component</span>:...</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;&#125;,</span><br><span class="line">              ...</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:...</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="路由的query参数"><a href="#路由的query参数" class="headerlink" title="路由的query参数"></a>路由的query参数</h3><p>当通过<router-link>标签跳转显示组件时，可以通过url向其传入参数，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过?后面的数据传入参数传入参数</span></span><br><span class="line"><span class="comment">//1.普通写法</span></span><br><span class="line">&lt;router-link to=<span class="string">&quot;/a1?a=1&amp;b=2&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;link&quot;</span>&gt;a1&lt;/router-link&gt;</span><br><span class="line"><span class="comment">//2.对象写法</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">path:&quot;</span>/<span class="attr">..</span>/<span class="attr">..</span>/<span class="attr">....</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">query:</span>&#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">a:..</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">...</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&quot; <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//组件可以通过以下方式获得传入的参数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.[...(参数名)]</span><br></pre></td></tr></table></figure>

<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>为每一个路由加上名字，方便使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单独的配置文件</span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">    //设置路由规则</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            //路径和组件以及名字</span><br><span class="line">            path:&#x27;/about&#x27;</span><br><span class="line">            component:About,</span><br><span class="line">            name:&quot;test&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:...</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//使用文件</span><br><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">name:&quot;test&quot;</span><br><span class="line">&#125;&quot; class=&quot;link&quot;&gt;a1&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><p>与query参数作用类似，但通过另一种方式实现参数的传递。</p>
<h3 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h3><p>router-link有一个属性replace用于设置是否替换历史记录，默认为不开启。开启后跳转后不可后退</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :replace=&quot;true&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<h2 id="VUE3-与vue2的差异"><a href="#VUE3-与vue2的差异" class="headerlink" title="VUE3(与vue2的差异)"></a>VUE3(与vue2的差异)</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>可以在此处设置变量和函数，之后再返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup()&#123;</span><br><span class="line">a=..</span><br><span class="line">...</span><br><span class="line">f=function()&#123;&#125;;</span><br><span class="line">//返回数据</span><br><span class="line">return &#123;</span><br><span class="line">a,</span><br><span class="line">b</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">//返回渲染函数</span><br><span class="line">import h from &quot;vue&quot;</span><br><span class="line">return ()=&gt;&#123;</span><br><span class="line">return h(&quot;h1&quot;,&quot;h1内部的内容&quot;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setup函数内部可以取代data,methods,computed的作用，但是这三个属性还可以使用，但是setup不可以读取到这三个属性的属性，但是这三个属性可以读取setup中的属性,如果setup和这三个属性有同名，setup内的属性会覆盖其他属性中的属性。</p>
<p>setup函数的执行时机是在beforCreat生命周期前,在此时函数内的this指向未定义。</p>
<p>setup函数执行时接收两个参数:props:包含组件外部传入的且组件内部声明过的props参数。</p>
<p>context:上下文参数:</p>
<pre><code>                                        + attrs:包含组件外部传入的且未在组件内部声明过的props参数。
                                        + slots:收到的插槽内容,相当于this.$slots。
                                        + emit:分发自定义事件的函数,相当于vue2中的this.$emit。
</code></pre>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive函数的作用实际上实现了对象代理(Proxy),无法对于基本类型使用reactive,更多解释参见下一小节。</p>
<h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用方法</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ref from &quot;vue&quot;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        //对象默认不是响应式,通过对对象包裹ref实现对包裹对象的响应式</span><br><span class="line">        a=ref(1)</span><br><span class="line">        b=ref(...)</span><br><span class="line">        //通过以下方法响应式的更改数据</span><br><span class="line">        a.value=2</span><br><span class="line">        b.value=...</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过ref,vue3实现了对于对象的监听和响应。其中,对于对象本身的监听还是通过getter和setter实现的。但是对于对象内部的属性则是通过代理(Proxy)实现(通过vue3中的新函数:reactive)的。</p>
<p>对于基本类型数据,使用ref会将值直接传入构造对象的value中。而对于对象数据，使用ref会将值作为参数先调用reactive函数，后将返回值直接传入构造对象的value中。</p>
<p>reactive函数的作用实际上实现了对象代理(Proxy),无法对于基本类型使用reactive</p>
<h3 id="vue3中的computed"><a href="#vue3中的computed" class="headerlink" title="vue3中的computed"></a>vue3中的computed</h3><p>vue3中的computed可以使用vue2中的写法，也可以配置在setup函数中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;computed&#125; from &quot;vue&quot;</span><br><span class="line">setup()&#123;</span><br><span class="line">p=&#123;a:1,b:2&#125;</span><br><span class="line">//computed的使用</span><br><span class="line">//简写形式</span><br><span class="line">c=computed(()=&gt;&#123;</span><br><span class="line">return p.a+p.b</span><br><span class="line">&#125;)</span><br><span class="line">//完整形式</span><br><span class="line">c=computed(&#123;</span><br><span class="line">get()&#123;...&#125;,</span><br><span class="line">set(value)&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">p,c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vue3中的watch"><a href="#vue3中的watch" class="headerlink" title="vue3中的watch"></a>vue3中的watch</h3><p>vue3中的watch可以使用vue2中的写法，也可以配置在setup函数中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;watch,ref&#125; from &quot;vue&quot;</span><br><span class="line">setup()&#123;</span><br><span class="line">a=ref(1)</span><br><span class="line"></span><br><span class="line">//1.监视一个属性的变化</span><br><span class="line">watch(a,(new,old)=&#123;&#125;)</span><br><span class="line">//2.监视多个属性的变化,此时new,old为两个数组，内部存储多新旧值</span><br><span class="line">watch([a,...],(new,old)=&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">//3.完整配置写法</span><br><span class="line">watch(a,(new,old)=&#123;&#125;,&#123;</span><br><span class="line">immediate:true,   //初始化是否执行</span><br><span class="line">deep:true   //是否深层监视,但是vue3使用了代理,已经强制开启了深度监视,此配置项无用。但是当监视对象为某个对象内部的子对象时,需要使用deep配置才可以深度监视。当使用ref监视对象时,监视的是value属性而不会深入到value属性内部,需要使用deep才可以。当监视的是代理对象时直接可以深度监视,不必使用deep选项。</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//当使用watch监视一个对象时,无法正确获取到旧值,新值和旧值均指向新值。(直接通过reactive配置的属性watch可以检测到对象属性的变化,通过ref间接调用reative的watch会监视value的变化而不会监视值的变化)</span><br><span class="line"></span><br><span class="line">//4.监视某个对象中的一个或一些属性</span><br><span class="line">a=&#123;a:1,b:2,c:3&#125;</span><br><span class="line">a=ref(a)</span><br><span class="line">watch([()=a.a,()=&gt;a.b,()=&gt;a.c)],(new,old)=&#123;&#125;,&#123;</span><br><span class="line">immediate:true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>类似于watch，但是不需要显式的指定要监视的属性,会自动监视函数体中所用的属性变化,改变时调用函数。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>vue3中的生命周期相对于vue2更改了两个名字,分别为:beforeUnmount和unmount以取代原来的destroy的一对函数。vue3可以使用vue2的写法，使用选项式的写法。</p>
<p>也可以使用组合式的写法配置,将其写入setup函数中,具体用法及名称如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate,created==&gt;setup()</span><br><span class="line">beforeMount==&gt;onBeforeMount</span><br><span class="line">mounted==&gt;onMounted</span><br><span class="line">beforeUpdate==&gt;onBeforeUpdate</span><br><span class="line">updated==&gt;onUpdated</span><br><span class="line">beforeUnmount==&gt;onBeforeUnmount</span><br><span class="line">unmounted==&gt;onUnmounted</span><br><span class="line"></span><br><span class="line">//通过向这些函数内传入执行函数即可实现使用</span><br><span class="line">import &#123;onBeforeMount,...&#125; from &quot;vue&quot;</span><br><span class="line">setup()&#123;</span><br><span class="line">onBeforeMount(()=&gt;&#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义hook函数"><a href="#自定义hook函数" class="headerlink" title="自定义hook函数"></a>自定义hook函数</h3><p>将组件setup函数中部分可以复用的代码单独写一个js文件，通过一个函数返回需要的数据。类似于vue2中的mixin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//hook函数文件  useTest.js</span><br><span class="line">//引用各种函数</span><br><span class="line">import &#123;onMounted&#125; from &quot;vue&quot;</span><br><span class="line">export default function()&#123;</span><br><span class="line">a=&#123;a:1,b:2&#125;</span><br><span class="line">//添加事件</span><br><span class="line">...</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//vue组件</span><br><span class="line">import useTest from &quot;./useTest.js&quot;</span><br><span class="line">setup()&#123;</span><br><span class="line">a=useTest()</span><br><span class="line">return &#123;a&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy(代理)"></a>Proxy(代理)</h2><p>代理是js原生的一种监听对象变化的强大属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a=&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:..,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b=<span class="keyword">new</span> <span class="title class_">Proxy</span>(a,&#123;</span><br><span class="line">    <span class="comment">//获得属性时调用</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target,propname</span>)&#123;</span><br><span class="line">        <span class="comment">//target代表代理的原对象,propname代表获得的属性名</span></span><br><span class="line">        <span class="comment">//当获得对象属性和添加属性时，会调用该方法</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//修改属性时调用</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target,propname,value</span>)&#123;</span><br><span class="line">        <span class="comment">//target代表代理的原对象,propname代表获得的属性名,value代表要修改的值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//删除属性时调用</span></span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target,propname</span>)&#123;</span><br><span class="line">        <span class="comment">//target代表代理的原对象,propname代表获得的属性名</span></span><br><span class="line">        <span class="comment">//执行相关操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>许多Object中的方法被移植到了Reflect中，并进行了改进。</p>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>默认</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用笔记</title>
    <url>/2023/09/24/hexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="关于hexo的使用说明"><a href="#关于hexo的使用说明" class="headerlink" title="关于hexo的使用说明"></a>关于hexo的使用说明</h1><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p><a href="https://hexo.io/zh-cn/">Hexo</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p>
<p>hexo clean:用于清除public文件中所有已经生成的文件，便于后续生成新文件时不必引起冲突</p>
</li>
</ol>
<span id="more"></span>
<p>   hexo g:用于将source文件夹中写好的md文件生成为html文件</p>
<p>   hexo d:用于将已经生成好的网站推送到远程服务器上</p>
<ol start="2">
<li><p>hexo new [type] {文件名}</p>
<p>用于在source文件夹中生成一个指定名称的带有预设格式的md文档</p>
<p>type用于指定格式，默认为post</p>
</li>
<li><p>hexo s</p>
<p>用于在本地启动一个服务器用于测试</p>
</li>
</ol>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h3 id="主题-六角形-hexo-io"><a href="#主题-六角形-hexo-io" class="headerlink" title="主题 |六角形 (hexo.io)"></a><a href="https://hexo.io/themes/">主题 |六角形 (hexo.io)</a></h3><h3 id="hexo-theme-ayer"><a href="#hexo-theme-ayer" class="headerlink" title="hexo-theme-ayer"></a><strong><a href="https://github.com/shen-yu/hexo-theme-ayer">hexo-theme-ayer</a></strong></h3><h3 id="三钻-Benny-X-Guo-三钻-Benny-X-Guo-tridiamond-tech"><a href="#三钻-Benny-X-Guo-三钻-Benny-X-Guo-tridiamond-tech" class="headerlink" title="三钻 Benny X Guo | 三钻 Benny X Guo (tridiamond.tech)"></a><a href="https://tridiamond.tech/">三钻 Benny X Guo | 三钻 Benny X Guo (tridiamond.tech)</a></h3><h3 id="Theme-Yuzu-专注文字-cerallin-github-io"><a href="#Theme-Yuzu-专注文字-cerallin-github-io" class="headerlink" title="Theme Yuzu - 专注文字 (cerallin.github.io)"></a><a href="https://cerallin.github.io/">Theme Yuzu - 专注文字 (cerallin.github.io)</a></h3><p> <a href="https://github.com/cerallin/hexo-theme-yuzu">Cerallin&#x2F;hexo-theme-yuzu: A simple black&#x2F;white hexo theme for novel reading. (github.com)</a></p>
<h3 id="君の名は-iloveu-xyz"><a href="#君の名は-iloveu-xyz" class="headerlink" title="君の名は (iloveu.xyz)"></a><a href="https://iloveu.xyz/">君の名は (iloveu.xyz)</a></h3><p><a href="https://github.com/JackZong/hexo-theme-burgerking">JackZong&#x2F;hexo-theme-burgerking: A simple hexo theme. (github.com)</a></p>
<h3 id="海风博客-分享代码与创意-hinpc-github-io"><a href="#海风博客-分享代码与创意-hinpc-github-io" class="headerlink" title="海风博客 - 分享代码与创意 (hinpc.github.io)"></a><a href="https://hinpc.github.io/Daily/">海风博客 - 分享代码与创意 (hinpc.github.io)</a></h3><p><a href="https://github.com/GallenHu/hexo-theme-Daily">GallenHu&#x2F;hexo-theme-Daily: A simple theme for Hexo (github.com)</a></p>
<h3 id="本博客，已开源，关于itsNeko开源博客食用方法-itsNeko「生活日志」-dyfa-top"><a href="#本博客，已开源，关于itsNeko开源博客食用方法-itsNeko「生活日志」-dyfa-top" class="headerlink" title="本博客，已开源，关于itsNeko开源博客食用方法 | itsNeko「生活日志」 (dyfa.top)"></a><a href="https://blog.dyfa.top/posts/itsneko-opensource-blog.html">本博客，已开源，关于itsNeko开源博客食用方法 | itsNeko「生活日志」 (dyfa.top)</a></h3>]]></content>
      <categories>
        <category>默认</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib学习记录</title>
    <url>/2023/09/24/matplotlib%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="图表的创建方法"><a href="#图表的创建方法" class="headerlink" title="图表的创建方法"></a>图表的创建方法</h2><p>创建新图形的最简单方法是使用 pyplot：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()  <span class="comment"># an empty figure with no Axes</span></span><br><span class="line">fig, ax = plt.subplots()  <span class="comment"># a figure with a single Axes</span></span><br><span class="line"><span class="comment">#添加axes</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot()</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">fig, axs = plt.subplots(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># a figure with a 2x2 grid of Axes</span></span><br><span class="line"><span class="comment">#3,添加并控制形状</span></span><br><span class="line"><span class="comment"># a figure with one axes on the left, and two on the right:控制不同子图的形状</span></span><br><span class="line">fig, axs = plt.subplot_mosaic([[<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right_top&#x27;</span>],</span><br><span class="line">                               [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right_bottom&#x27;</span>]])</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="面向对象接口的基本使用"><a href="#面向对象接口的基本使用" class="headerlink" title="面向对象接口的基本使用"></a>面向对象接口的基本使用</h2><h3 id="设置标题和图例等"><a href="#设置标题和图例等" class="headerlink" title="设置标题和图例等"></a>设置标题和图例等</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)  <span class="comment"># Sample data.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">2.7</span>), layout=<span class="string">&#x27;constrained&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置整个图像的属性</span></span><br><span class="line"><span class="comment">#标题</span></span><br><span class="line">fig.suptitle(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">fig.figtext(<span class="string">&quot;sss&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画图并设置图例名</span></span><br><span class="line">ax.plot(x, x, label=<span class="string">&#x27;linear&#x27;</span>)  <span class="comment"># Plot some data on the axes.</span></span><br><span class="line">ax.plot(x, x**<span class="number">2</span>, label=<span class="string">&#x27;quadratic&#x27;</span>)  <span class="comment"># Plot more data on the axes...</span></span><br><span class="line">ax.plot(x, x**<span class="number">3</span>, label=<span class="string">&#x27;cubic&#x27;</span>)  <span class="comment"># ... and some more.</span></span><br><span class="line"><span class="comment">#对象式设置图例</span></span><br><span class="line">line, = ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">line.set_label(<span class="string">&#x27;Label via method&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置x,y标签和标题</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x label&#x27;</span>)  <span class="comment"># Add an x-label to the axes.</span></span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y label&#x27;</span>)  <span class="comment"># Add a y-label to the axes.</span></span><br><span class="line">ax.set_title(<span class="string">&quot;Simple Plot&quot;</span>)  <span class="comment"># Add a title to the axes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用tex渲染文字,+r</span></span><br><span class="line">ax.set_ylabel(<span class="string">r&#x27;$\int\ Y^2\ dt\ \ [V^2 s]$&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#labelpad可以控制指定轴(x,y)在指定方向的坐标偏移</span></span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;entry b&#x27;</span>,labelpad=-<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置坐标轴的刻度</span></span><br><span class="line">ax.xaxis.set_ticks(np.linspace(<span class="number">0</span>,<span class="number">50</span>,<span class="number">3</span>))</span><br><span class="line">ax.yaxis...</span><br><span class="line"><span class="comment">#设置自定义的坐标轴刻度</span></span><br><span class="line">ax.set_xticks(np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>), [<span class="string">&#x27;zero&#x27;</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;sixty&#x27;</span>, <span class="string">&#x27;90&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置坐标的比例</span></span><br><span class="line">ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)  <span class="comment">#设置比例为对数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示已添加的图例</span></span><br><span class="line">ax.legend()  <span class="comment"># Add a legend.</span></span><br><span class="line"><span class="comment">#控制显示的图例</span></span><br><span class="line">line1, = ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], label=<span class="string">&#x27;label1&#x27;</span>)</span><br><span class="line">line2, = ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], label=<span class="string">&#x27;label2&#x27;</span>)</span><br><span class="line">ax.legend([line1, line2], [<span class="string">&#x27;label111&#x27;</span>, <span class="string">&#x27;label222&#x27;</span>]（别名）)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在图像中添加文字,前两个参数设置文字坐标位置</span></span><br><span class="line">ax.text(<span class="number">75</span>, <span class="number">.025</span>,<span class="string">&quot;text&quot;</span>,fontsize=<span class="number">50</span>,color=(<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.5</span>,<span class="number">0.4</span>))</span><br><span class="line"><span class="comment">#添加提示文字,xy代表箭头起点,xytext代表文字位置</span></span><br><span class="line">ax.annotate(<span class="string">&#x27;annotate&#x27;</span>, xy=(<span class="number">2</span>, <span class="number">1</span>), xytext=(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">            arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, shrink=<span class="number">0.05</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置x,y坐标的范围</span></span><br><span class="line">ax.axis([<span class="number">55</span>, <span class="number">175</span>, <span class="number">0</span>, <span class="number">0.03</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置是否显示网格</span></span><br><span class="line">ax.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="设置样式的方法"><a href="#设置样式的方法" class="headerlink" title="设置样式的方法"></a>设置样式的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置样式</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">2.7</span>))</span><br><span class="line">x = np.arange(<span class="built_in">len</span>(data1))</span><br><span class="line"><span class="comment">#在画图时设置</span></span><br><span class="line">ax.plot(x, np.cumsum(data1), color=<span class="string">&#x27;blue&#x27;</span>, linewidth=<span class="number">3</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"><span class="comment">#面向对象设置方法</span></span><br><span class="line">l, = ax.plot(x, np.cumsum(data2), color=<span class="string">&#x27;orange&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">l.set_linestyle(<span class="string">&#x27;:&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="设置图像之间的遮盖关系z-index"><a href="#设置图像之间的遮盖关系z-index" class="headerlink" title="设置图像之间的遮盖关系z-index"></a>设置图像之间的遮盖关系z-index</h3><p>不同形状的图像有默认的显示优先级，可以通过设置改变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">7.5</span>, <span class="number">100</span>)</span><br><span class="line">plt.rcParams[<span class="string">&#x27;lines.linewidth&#x27;</span>] = <span class="number">5</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment">#函数参数设置zorder</span></span><br><span class="line">plt.plot(x, np.sin(x), label=<span class="string">&#x27;zorder=2&#x27;</span>, zorder=<span class="number">2</span>)  <span class="comment"># bottom</span></span><br><span class="line">plt.plot(x, np.sin(x+<span class="number">0.5</span>), label=<span class="string">&#x27;zorder=3&#x27;</span>,  zorder=<span class="number">3</span>)</span><br><span class="line">plt.axhline(<span class="number">0</span>, label=<span class="string">&#x27;zorder=2.5&#x27;</span>, color=<span class="string">&#x27;lightgrey&#x27;</span>, zorder=<span class="number">2.5</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Custom order of elements&#x27;</span>)</span><br><span class="line"><span class="comment">#对象设置</span></span><br><span class="line">l = plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">l.set_zorder(<span class="number">2.5</span>)  <span class="comment"># legend between blue and orange line</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="颜色的设置"><a href="#颜色的设置" class="headerlink" title="颜色的设置"></a>颜色的设置</h3><p>颜色可以使用字符串和rgba等多种形式，使用rgba所有值在0-1之间,<code>color=(0.2,0.3,0.4,0.2)</code></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>默认</tag>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas学习记录</title>
    <url>/2023/09/24/pandas%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p><code>Series</code>是带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。轴标签统称为<strong>索引</strong>。调用 <code>pd.Series</code> 函数即可创建 Series</p>
<span id="more"></span>
<h3 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h3><ol>
<li><p>数组</p>
<p><code>data</code> 是多维数组时，<strong>index</strong> 长度必须与 <strong>data</strong> 长度一致。没有指定 <code>index</code> 参数时，创建数值型索引，即 <code>[0, ..., len(data) - 1]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: s = pd.Series(np.random.randn(<span class="number">5</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: s</span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line">a    <span class="number">0.469112</span></span><br><span class="line">b   -<span class="number">0.282863</span></span><br><span class="line">c   -<span class="number">1.509059</span></span><br><span class="line">d   -<span class="number">1.135632</span></span><br><span class="line">e    <span class="number">1.212112</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: s.index</span><br><span class="line">Out[<span class="number">5</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: pd.Series(np.random.randn(<span class="number">5</span>))</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line"><span class="number">0</span>   -<span class="number">0.173215</span></span><br><span class="line"><span class="number">1</span>    <span class="number">0.119209</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1.044236</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.861849</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">2.104569</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典</p>
<p>Series 可以用字典实例化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: d = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: pd.Series(d)</span><br><span class="line">Out[<span class="number">8</span>]: </span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>如果设置了 <code>index</code> 参数，则按索引标签提取 <code>data</code> 里对应的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0.</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1.</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2.</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: pd.Series(d)</span><br><span class="line">Out[<span class="number">10</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: pd.Series(d, index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    NaN</span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ol>
<li><p>一些函数</p>
<p><code>Series</code> 操作与 <code>ndarray</code> 类似，支持大多数 NumPy 函数，还支持索引切片。</p>
<p><code>Series.array</code> 用于提取 <code>Series</code> 数组，不是ndarray</p>
<p>Series 是<code>扩展数组</code> ，<code>Series.to_numpy()</code> 返回的是 NumPy 多维数组。</p>
</li>
<li><p>索引切片</p>
<p><code>Series</code> 操作与 <code>ndarray</code> 类似，支持大多数 NumPy 函数，还支持索引切片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: s[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">0.4691122999071863</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: s[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">a    <span class="number">0.469112</span></span><br><span class="line">b   -<span class="number">0.282863</span></span><br><span class="line">c   -<span class="number">1.509059</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: s[s &gt; s.median()]</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">a    <span class="number">0.469112</span></span><br><span class="line">e    <span class="number">1.212112</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: s[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">e    <span class="number">1.212112</span></span><br><span class="line">d   -<span class="number">1.135632</span></span><br><span class="line">b   -<span class="number">0.282863</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>Series 类似固定大小的字典，可以用索引标签提取值或设置值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: s[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">21</span>]: <span class="number">0.4691122999071863</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: s[<span class="string">&#x27;e&#x27;</span>] = <span class="number">12.</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: s</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">a     <span class="number">0.469112</span></span><br><span class="line">b    -<span class="number">0.282863</span></span><br><span class="line">c    -<span class="number">1.509059</span></span><br><span class="line">d    -<span class="number">1.135632</span></span><br><span class="line">e    <span class="number">12.000000</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> s</span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: <span class="string">&#x27;f&#x27;</span> <span class="keyword">in</span> s</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><code>get</code> 方法可以提取 <code>Series</code> 里没有的标签，返回 <code>None</code> 或指定默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: s.get(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: s.get(<span class="string">&#x27;f&#x27;</span>, np.nan)</span><br><span class="line">Out[<span class="number">27</span>]: nan</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="矢量操作与对齐-Series-标签"><a href="#矢量操作与对齐-Series-标签" class="headerlink" title="矢量操作与对齐 Series 标签"></a>矢量操作与对齐 Series 标签</h3><p>Series 和 NumPy 数组一样，都不用循环每个值，而且 Series 支持大多数 NumPy 多维数组的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: s + s</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">a     <span class="number">0.938225</span></span><br><span class="line">b    -<span class="number">0.565727</span></span><br><span class="line">c    -<span class="number">3.018117</span></span><br><span class="line">d    -<span class="number">2.271265</span></span><br><span class="line">e    <span class="number">24.000000</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>Series 和多维数组的主要区别在于， Series 之间的操作会自动基于标签对齐数据。因此，不用顾及执行计算操作的 Series 是否有相同的标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: s[<span class="number">1</span>:] + s[:-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">a         NaN</span><br><span class="line">b   -<span class="number">0.565727</span></span><br><span class="line">c   -<span class="number">3.018117</span></span><br><span class="line">d   -<span class="number">2.271265</span></span><br><span class="line">e         NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>操作未对齐索引的 Series， 其计算结果是所有涉及索引的<strong>并集</strong>。如果在 Series 里找不到标签，运算结果标记为 <code>NaN</code>，即缺失值。编写无需显式对齐数据的代码，给交互数据分析和研究提供了巨大的自由度和灵活性。Pandas 数据结构集成的数据对齐功能，是 Pandas 区别于大多数标签型数据处理工具的重要特性。</p>
<p>series有部分运算无法使用numpy的方法,如|，&amp;，~,需要替换为numpy.logic_and,or,not()等等。</p>
<p>series支持name属性，使用rename重命名</p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p><strong>DataFrame</strong> 是由多种类型的列构成的二维标签数据结构，类似于 Excel 、SQL 表，或 Series 对象构成的字典。DataFrame 是最常用的 Pandas 对象，与 Series 一样，DataFrame 支持多种类型的输入数据：</p>
<ul>
<li>一维 ndarray、列表、字典、Series 字典</li>
<li>二维 numpy.ndarray</li>
<li>结构多维数组或记录多维数</li>
<li><code>Series</code></li>
<li><code>DataFrame</code></li>
</ul>
<p>除了数据，还可以有选择地传递 <strong>index</strong>（行标签）和 <strong>columns</strong>（列标签）参数。传递了索引或列，就可以确保生成的 DataFrame 里包含索引或列。Series 字典加上指定索引时，会丢弃与传递的索引不匹配的所有数据。</p>
<p>没有传递轴标签时，按常规依据输入数据进行构建。</p>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><ol>
<li><p>用series字典生成</p>
<p>生成的<strong>索引</strong>是每个 <strong>Series</strong> 索引的并集。先把嵌套字典转换为 Series。如果没有指定列，DataFrame 的列就是字典键的有序列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: d = &#123;<span class="string">&#x27;one&#x27;</span>: pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">   ....:      <span class="string">&#x27;two&#x27;</span>: pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: df</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">   one  two</span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span></span><br><span class="line">c  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">d  NaN  <span class="number">4.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: pd.DataFrame(d, index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">   one  two</span><br><span class="line">d  NaN  <span class="number">4.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span></span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: pd.DataFrame(d, index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], columns=[<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line">   two three</span><br><span class="line">d  <span class="number">4.0</span>   NaN</span><br><span class="line">b  <span class="number">2.0</span>   NaN</span><br><span class="line">a  <span class="number">1.0</span>   NaN</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="提取、添加、删除列"><a href="#提取、添加、删除列" class="headerlink" title="提取、添加、删除列"></a>提取、添加、删除列</h3><p>DataFrame 就像带索引的 Series 字典，提取、设置、删除列的操作与字典类似：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: df[<span class="string">&#x27;one&#x27;</span>]</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">a    <span class="number">1.0</span></span><br><span class="line">b    <span class="number">2.0</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">d    NaN</span><br><span class="line">Name: one, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: df[<span class="string">&#x27;three&#x27;</span>] = df[<span class="string">&#x27;one&#x27;</span>] * df[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: df[<span class="string">&#x27;flag&#x27;</span>] = df[<span class="string">&#x27;one&#x27;</span>] &gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: df</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">   one  two  three   flag</span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span>    <span class="number">1.0</span>  <span class="literal">False</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span>    <span class="number">4.0</span>  <span class="literal">False</span></span><br><span class="line">c  <span class="number">3.0</span>  <span class="number">3.0</span>    <span class="number">9.0</span>   <span class="literal">True</span></span><br><span class="line">d  NaN  <span class="number">4.0</span>    NaN  <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>删除（del、pop）列的方式也与字典类似：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: <span class="keyword">del</span> df[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: three = df.pop(<span class="string">&#x27;three&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: df</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">   one   flag</span><br><span class="line">a  <span class="number">1.0</span>  <span class="literal">False</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="literal">False</span></span><br><span class="line">c  <span class="number">3.0</span>   <span class="literal">True</span></span><br><span class="line">d  NaN  <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>标量值以广播的方式填充列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: df[<span class="string">&#x27;foo&#x27;</span>] = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: df</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">   one   flag  foo</span><br><span class="line">a  <span class="number">1.0</span>  <span class="literal">False</span>  bar</span><br><span class="line">b  <span class="number">2.0</span>  <span class="literal">False</span>  bar</span><br><span class="line">c  <span class="number">3.0</span>   <span class="literal">True</span>  bar</span><br><span class="line">d  NaN  <span class="literal">False</span>  bar</span><br></pre></td></tr></table></figure>

<p>插入与 DataFrame 索引不同的 Series 时，以 DataFrame 的索引为准：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: df[<span class="string">&#x27;one_trunc&#x27;</span>] = df[<span class="string">&#x27;one&#x27;</span>][:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: df</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">   one   flag  foo  one_trunc</span><br><span class="line">a  <span class="number">1.0</span>  <span class="literal">False</span>  bar        <span class="number">1.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="literal">False</span>  bar        <span class="number">2.0</span></span><br><span class="line">c  <span class="number">3.0</span>   <span class="literal">True</span>  bar        NaN</span><br><span class="line">d  NaN  <span class="literal">False</span>  bar        NaN</span><br></pre></td></tr></table></figure>

<p>可以插入原生多维数组，但长度必须与 DataFrame 索引长度一致。</p>
<p>默认在 DataFrame 尾部插入列。<code>insert</code> 函数可以指定插入列的位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: df.insert(<span class="number">1</span>, <span class="string">&#x27;bar&#x27;</span>, df[<span class="string">&#x27;one&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: df</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">   one  bar   flag  foo  one_trunc</span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="literal">False</span>  bar        <span class="number">1.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span>  <span class="literal">False</span>  bar        <span class="number">2.0</span></span><br><span class="line">c  <span class="number">3.0</span>  <span class="number">3.0</span>   <span class="literal">True</span>  bar        NaN</span><br><span class="line">d  NaN  NaN  <span class="literal">False</span>  bar        NaN</span><br></pre></td></tr></table></figure>

<h3 id="索引-选择"><a href="#索引-选择" class="headerlink" title="索引 &#x2F; 选择"></a>索引 &#x2F; 选择</h3><p>索引基础用法如下：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>句法</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>选择列</td>
<td><code>df[col]</code></td>
<td>Series</td>
</tr>
<tr>
<td>用标签选择行</td>
<td><code>df.loc[label]</code></td>
<td>Series</td>
</tr>
<tr>
<td>用整数位置选择行</td>
<td><code>df.iloc[loc]</code></td>
<td>Series</td>
</tr>
<tr>
<td>行切片</td>
<td><code>df[5:10]</code></td>
<td>DataFrame</td>
</tr>
<tr>
<td>用布尔向量选择行</td>
<td><code>df[bool_vec]</code></td>
<td>DataFrame</td>
</tr>
</tbody></table>
<p>在loc和iloc上可以使用与ndarray类似的多重索引,如().iloc[1:2,3:5:8]。loc使用标签索引，iloc使用数字索引</p>
<p>选择行返回 Series，索引是 DataFrame 的列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: df.loc[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line">one              <span class="number">2</span></span><br><span class="line">bar              <span class="number">2</span></span><br><span class="line">flag         <span class="literal">False</span></span><br><span class="line">foo            bar</span><br><span class="line">one_trunc        <span class="number">2</span></span><br><span class="line">Name: b, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: df.iloc[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line">one             <span class="number">3</span></span><br><span class="line">bar             <span class="number">3</span></span><br><span class="line">flag         <span class="literal">True</span></span><br><span class="line">foo           bar</span><br><span class="line">one_trunc     NaN</span><br><span class="line">Name: c, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>

<h4 id="在loc选择器上的操作"><a href="#在loc选择器上的操作" class="headerlink" title="在loc选择器上的操作"></a>在loc选择器上的操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;AAA&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">   ...:                    <span class="string">&#x27;BBB&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>],</span><br><span class="line">   ...:                    <span class="string">&#x27;CCC&#x27;</span>: [<span class="number">100</span>, <span class="number">50</span>, -<span class="number">30</span>, -<span class="number">50</span>]&#125;)</span><br><span class="line">   ...: </span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: df</span><br><span class="line">Out[<span class="number">2</span>]: </span><br><span class="line">   AAA  BBB  CCC</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span>   <span class="number">10</span>  <span class="number">100</span></span><br><span class="line"><span class="number">1</span>    <span class="number">5</span>   <span class="number">20</span>   <span class="number">50</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span>   <span class="number">30</span>  -<span class="number">30</span></span><br><span class="line"><span class="number">3</span>    <span class="number">7</span>   <span class="number">40</span>  -<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在一列上执行 if-then 操作：</span></span><br><span class="line">In [<span class="number">3</span>]: df.loc[df.AAA &gt;= <span class="number">5</span>, <span class="string">&#x27;BBB&#x27;</span>] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: df</span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line">   AAA  BBB  CCC</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span>   <span class="number">10</span>  <span class="number">100</span></span><br><span class="line"><span class="number">1</span>    <span class="number">5</span>   -<span class="number">1</span>   <span class="number">50</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span>   -<span class="number">1</span>  -<span class="number">30</span></span><br><span class="line"><span class="number">3</span>    <span class="number">7</span>   -<span class="number">1</span>  -<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在两列上执行 if-then 操作：</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: df.loc[df.AAA &gt;= <span class="number">5</span>, [<span class="string">&#x27;BBB&#x27;</span>, <span class="string">&#x27;CCC&#x27;</span>]] = <span class="number">555</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: df</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">   AAA  BBB  CCC</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span>   <span class="number">10</span>  <span class="number">100</span></span><br><span class="line"><span class="number">1</span>    <span class="number">5</span>  <span class="number">555</span>  <span class="number">555</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span>  <span class="number">555</span>  <span class="number">555</span></span><br><span class="line"><span class="number">3</span>    <span class="number">7</span>  <span class="number">555</span>  <span class="number">555</span></span><br></pre></td></tr></table></figure>

<h3 id="where函数的妙用"><a href="#where函数的妙用" class="headerlink" title="where函数的妙用"></a>where函数的妙用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;AAA&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;BBB&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;CCC&#x27;</span>: [<span class="number">100</span>, <span class="number">50</span>, -<span class="number">30</span>, -<span class="number">50</span>]&#125;)</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: df</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line">   AAA  BBB  CCC</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span>   <span class="number">10</span>  <span class="number">100</span></span><br><span class="line"><span class="number">1</span>    <span class="number">5</span>   <span class="number">20</span>   <span class="number">50</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span>   <span class="number">30</span>  -<span class="number">30</span></span><br><span class="line"><span class="number">3</span>    <span class="number">7</span>   <span class="number">40</span>  -<span class="number">50</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: df[<span class="string">&#x27;logic&#x27;</span>] = np.where(df[<span class="string">&#x27;AAA&#x27;</span>] &gt; <span class="number">5</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: df</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">   AAA  BBB  CCC logic</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span>   <span class="number">10</span>  <span class="number">100</span>   low</span><br><span class="line"><span class="number">1</span>    <span class="number">5</span>   <span class="number">20</span>   <span class="number">50</span>   low</span><br><span class="line"><span class="number">2</span>    <span class="number">6</span>   <span class="number">30</span>  -<span class="number">30</span>  high</span><br><span class="line"><span class="number">3</span>    <span class="number">7</span>   <span class="number">40</span>  -<span class="number">50</span>  high</span><br></pre></td></tr></table></figure>

<h3 id="argsort排序妙用"><a href="#argsort排序妙用" class="headerlink" title="argsort排序妙用"></a>argsort排序妙用</h3><p>使用argsort搭配iloc可以为表格进行排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;AAA&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;BBB&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;CCC&#x27;</span>: [<span class="number">100</span>, <span class="number">50</span>, -<span class="number">30</span>, -<span class="number">50</span>]&#125;)</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: df</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">   AAA  BBB  CCC</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span>   <span class="number">10</span>  <span class="number">100</span></span><br><span class="line"><span class="number">1</span>    <span class="number">5</span>   <span class="number">20</span>   <span class="number">50</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span>   <span class="number">30</span>  -<span class="number">30</span></span><br><span class="line"><span class="number">3</span>    <span class="number">7</span>   <span class="number">40</span>  -<span class="number">50</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: aValue = <span class="number">43.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: df.iloc[(df.CCC - aValue).<span class="built_in">abs</span>().argsort()]</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">   AAA  BBB  CCC</span><br><span class="line"><span class="number">1</span>    <span class="number">5</span>   <span class="number">20</span>   <span class="number">50</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span>   <span class="number">10</span>  <span class="number">100</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6</span>   <span class="number">30</span>  -<span class="number">30</span></span><br><span class="line"><span class="number">3</span>    <span class="number">7</span>   <span class="number">40</span>  -<span class="number">50</span></span><br><span class="line"><span class="comment">#也可以对列进行排序</span></span><br><span class="line">df.iloc[:,(表达式...).argsort()]</span><br></pre></td></tr></table></figure>

<h3 id="映射函数"><a href="#映射函数" class="headerlink" title="映射函数"></a>映射函数</h3><p>map函数对于Series的每个元素应用函数</p>
<p>apply对于Series的每个元素或DataFrame的每一列应用函数,可以额外传递参数。当对DataFrame使用函数时，可以传入参数axis&#x3D;…来改变传入的的是行还是列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_age</span>(<span class="params">x,bias</span>):</span><br><span class="line">    <span class="keyword">return</span> x+bias</span><br><span class="line"></span><br><span class="line"><span class="comment">#以元组的方式传入额外的参数</span></span><br><span class="line">data[<span class="string">&quot;age&quot;</span>] = data[<span class="string">&quot;age&quot;</span>].apply(apply_age,args=(-<span class="number">3</span>,))</span><br></pre></td></tr></table></figure>

<p>applymap对于表或者series中的每一个元素应用特定的函数并将结果返回到原位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.applymap(function)</span><br></pre></td></tr></table></figure>

<h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><p>max,min等函数返回表的每一列的最值,idxmax,idxmin,返回最值的索引</p>
<p>rename函数用来为dataframe的行和列重命名,如<code>d.rename(columns=&#123;&#39;y&#39;:&#39;yr&#39;&#125;,index=&#123;&#39;b&#39;:&#39;bkk&#39;&#125;,inplace=True)</code>，其中inplace参数代表是否改变原数组</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>默认</tag>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习记录</title>
    <url>/2023/09/24/numpy%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="创建ndarray的方法"><a href="#创建ndarray的方法" class="headerlink" title="创建ndarray的方法"></a>创建ndarray的方法</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>通过数组</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>zeros,empty,ones</p>
<p>…_like</p>
<span id="more"></span>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><ul>
<li><p>arange</p>
<p>类似于range</p>
</li>
<li><p>linspace</p>
<p>等分区间</p>
</li>
<li><p>fromfunction</p>
<p>按照函数生成，以下标为参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fromfunction(<span class="keyword">lambda</span> i,j:j,[<span class="number">4</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ndarray的一些方法"><a href="#ndarray的一些方法" class="headerlink" title="ndarray的一些方法"></a>ndarray的一些方法</h2><h3 id="1-自身的方法"><a href="#1-自身的方法" class="headerlink" title="1.自身的方法"></a>1.自身的方法</h3><p>sum,min,max</p>
<p>().sum()</p>
<p>可以使用axis指定维度</p>
<p>().sum(axis&#x3D;0,1,2…)</p>
<h3 id="2-numpy的一些方法"><a href="#2-numpy的一些方法" class="headerlink" title="2.numpy的一些方法"></a>2.numpy的一些方法</h3><p>在方法中使用axis&#x3D;None参数一般得到一个操作后的一维数组</p>
<ul>
<li><p>all,any (可以使用axis指定维度),用于判断数组中是否都是（或有）真值</p>
</li>
<li><p>sort,用于在指定轴对数组进行排序<code> np.sort(x, axis=0)</code>,不改变原数组</p>
</li>
<li><p>nonzero,用于获得数组中非零元素的坐标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">a &gt; <span class="number">3</span></span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]])</span><br><span class="line">np.nonzero(a &gt; <span class="number">3</span>)</span><br><span class="line">(array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]), array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>argmax,argmin,argsort,类似于去掉arg的函数，但是返回的是操作之后的数组的索引</p>
</li>
<li><p>mean,var,返回沿指定轴方向的平均值或方差，<code>np.var(a, axis=0)</code>,如果不指定axis会对全体数据求值</p>
</li>
<li><p>cross，dot，返回向量的叉积或行列式的值</p>
</li>
<li><p>cumsum计算数组沿着轴向的累加和，可以设置axis</p>
</li>
<li><p>where,相当于三元表达式? :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">a</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">np.where(a &lt; <span class="number">5</span>, a, <span class="number">10</span>*a)</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>])</span><br><span class="line">这也可以用于多维数组：</span><br><span class="line"></span><br><span class="line">np.where([[<span class="literal">True</span>, <span class="literal">False</span>], [<span class="literal">True</span>, <span class="literal">True</span>]],</span><br><span class="line">         [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]],</span><br><span class="line">         [[<span class="number">9</span>, <span class="number">8</span>], [<span class="number">7</span>, <span class="number">6</span>]])</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="变换数组自身"><a href="#变换数组自身" class="headerlink" title="变换数组自身"></a>变换数组自身</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>reshape</p>
<p>（-1自动计算大小)返回特定形状数组，不修改原数组</p>
<p>resize</p>
<p>修改原数组</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><ul>
<li><p>concatenate</p>
<p>拼接函数，可以按照特定axis方向(默认为0)拼接不同的数组,当axis为none时,会变成一维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组a,b</span></span><br><span class="line">concatenate((a,b),axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>stack</p>
<p>在指定的axis上增加一个维度，将数组堆叠起来,默认axis为0,要求数组的形状完全相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arrays = [np.random.randn(<span class="number">3</span>, <span class="number">4</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">np.stack(arrays, axis=<span class="number">0</span>).shape</span><br><span class="line">(<span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">np.stack(arrays, axis=<span class="number">1</span>).shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">np.stack(arrays, axis=<span class="number">2</span>).shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">np.stack((a, b))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">np.stack((a, b), axis=-<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>block</p>
<p>将数组按照自然的方式拼接起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.eye(<span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">B = np.eye(<span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">np.block([</span><br><span class="line">    [A,               np.zeros((<span class="number">2</span>, <span class="number">3</span>))],</span><br><span class="line">    [np.ones((<span class="number">3</span>, <span class="number">2</span>)), B               ]</span><br><span class="line">])</span><br><span class="line">array([[<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">2.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">3.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">3.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">3.</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="数组的浅拷贝和深拷贝"><a href="#数组的浅拷贝和深拷贝" class="headerlink" title="数组的浅拷贝和深拷贝"></a>数组的浅拷贝和深拷贝</h2><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>是浅拷贝，数组切片等返回的是view,对view的修改返回到源对象上</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>是深拷贝,返回一个新的对象</p>
</li>
</ul>
<h2 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h2><ul>
<li><p>索引数组</p>
<p>当索引数组<code>a</code>是多维的时，单个索引数组指的是第一个维度<code>a</code>，我们还可以为多个维度提供索引。每个维度的索引数组必须具有相同的形状</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = np.array( [ [<span class="number">0</span>,<span class="number">1</span>],                        <span class="comment"># indices for the first dim of a</span></span><br><span class="line"><span class="meta">... </span>                [<span class="number">1</span>,<span class="number">2</span>] ] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j = np.array( [ [<span class="number">2</span>,<span class="number">1</span>],                        <span class="comment"># indices for the second dim</span></span><br><span class="line"><span class="meta">... </span>                [<span class="number">3</span>,<span class="number">3</span>] ] )</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[i,j]                                     <span class="comment"># i and j must have equal shape</span></span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>布尔数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种方式</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a &gt; <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b                                          <span class="comment"># b is a boolean with a&#x27;s shape</span></span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[b]                                       <span class="comment"># 1d array with the selected elements</span></span><br><span class="line">array([ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种方式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1 = np.array([<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>])             <span class="comment"># first dim selection</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>])       <span class="comment"># second dim selection</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[b1,b2]                                  <span class="comment"># a weird thing to do</span></span><br><span class="line">array([ <span class="number">4</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>ix_函数</p>
<p>用于把向量生成为几个正交的向量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax,bx,cx = np.ix_(a,b,c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax</span><br><span class="line">array([[[<span class="number">2</span>]],</span><br><span class="line">       [[<span class="number">3</span>]],</span><br><span class="line">       [[<span class="number">4</span>]],</span><br><span class="line">       [[<span class="number">5</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bx</span><br><span class="line">array([[[<span class="number">8</span>],</span><br><span class="line">        [<span class="number">5</span>],</span><br><span class="line">        [<span class="number">4</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cx</span><br><span class="line">array([[[<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.shape, bx.shape, cx.shape</span><br><span class="line">((<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播的原则:在两个数组上操作时，NumPy 会逐个元素比较它们的形状。 它从尾随（即最右边）维度开始，并计算其 向左走。两个维度兼容以下情况</p>
<ol>
<li>它们是相等的，或者</li>
<li>其中之一是 1。</li>
</ol>
<p>如果不满足这些条件，则例外情况为 抛出，指示数组具有不兼容的形状。</p>
<p>赋值运算也会使用广播原则</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>默认</tag>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>李君生辰贺</title>
    <url>/2024/01/12/%E6%9D%8E%E5%90%9B%E7%94%9F%E8%BE%B0%E8%B4%BA/</url>
    <content><![CDATA[<p><img src="/2024/01/12/%E6%9D%8E%E5%90%9B%E7%94%9F%E8%BE%B0%E8%B4%BA/brithday.jpg" alt="brithday"></p>
<p>贺君之寿，诞生之辰，瑞气洋溢。谨赞江山壮丽，而今弄潮兮大三，少年翱翔于海南大学，学海无涯。</p>
<p>良宵之光，曙光将临，年方弱冠，志在人工智能。专攻学府，匡时弦歌，研究深沉于技艺之道，悦心灵之源泉。</p>
<p>开源之心，犹如明月之光，照亮黑夜，将知识之花开放。爱技术，好探究，彷彿江水悠悠，不息追求。喜得Linux之奇迹，操纵指尖之间，自在遨游于数据之海。</p>
<p>青春年华，翩然风华。愿君学海无涯，前程万里，步步高升。披荆斩棘，勇攀科技之峰，成就梦想之巅。</p>
<p>甲辰之岁，祝君心想事成，生辰快乐！</p>
<span id="more"></span>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
  <entry>
    <title>文章功能测试</title>
    <url>/2023/09/24/%E6%96%87%E7%AB%A0%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>美图<br><img src="/2023/09/24/%E6%96%87%E7%AB%A0%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/001.jpg" alt="005"></p>
<span id="more"></span>

<blockquote>
<p>一个小测试项目</p>
</blockquote>
<div align="center"><img width="200" height="150" src="./001.jpg"/></div>

<script> alert("大家好") </script>

<p><button type="button">Click Me!</button></p>
<div style="text-align: center">
    <p style="color: red;font-size: 40pt">一个html的测试</p>
</div>

<div>
    <script>
        xx=1
        te1=function () {
            alert(xx++);
        }
    </script>
    <button onclick="te1">
        点我
    </button>
</div>
]]></content>
      <categories>
        <category>默认</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
</search>
